package com.antivirus.scanner.utils;

import com.antivirus.scanner.Constant;
import com.antivirus.scanner.SectionTable;
import com.antivirus.scanner.entity.Malware;
import org.jetbrains.annotations.NotNull;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import java.io.IOException;
import java.io.RandomAccessFile;
import java.util.HashMap;
import java.util.List;

public final class MalwareUtils {
    final static Logger log = LoggerFactory.getLogger(MalwareUtils.class);
    private static List<Malware> malwares = StaticDataEngine.MALWARE_LIST;
    private static byte[] sectionBuffer;

    public static boolean checkInHead(@NotNull RandomAccessFile raf, int sectionRVA, int lastObjectEntry) throws IOException {
        int bytesToRead = sectionRVA - lastObjectEntry;
        byte[] fileInfo = new byte[bytesToRead];
        long seekPos = lastObjectEntry;
        raf.seek(seekPos);
        raf.readFully(fileInfo, 0, bytesToRead);

        return isInfected(fileInfo);
    }

    public static boolean checkSectionTail(@NotNull RandomAccessFile raf, @NotNull List<SectionTable> sections, int fileAlignment) throws IOException {
        HashMap<SectionTable, byte[]> pretendToScan = new HashMap<>();
        HashMap<SectionTable, byte[]> sectionToScan = new HashMap<>();

        for (SectionTable section : sections) {
            int physicalSize = section.getPhysicalSize();
            int physicalOffset = section.getPhysicalOffset();
            int virtualSize = section.getVirtualSize();
            int nextPhysicalOffset = 0;
            int freeBytes;
            boolean lastSection = false;

            String name = String.valueOf(section.getObjectName());
            log.info("Scanning section " + name);

            if (sections.indexOf(section) + 1 == sections.size()) {
                lastSection = true;
            } else {
                nextPhysicalOffset = sections.get(sections.indexOf(section) + 1).getPhysicalOffset();
            }

            if (physicalOffset + physicalSize > nextPhysicalOffset && !lastSection) {
                continue;
            }

            if (physicalSize > virtualSize || (virtualSize >= physicalSize && physicalSize > 0)) {
                if (lastSection) {
                    freeBytes = freeSpace(raf, physicalOffset, physicalSize);
                } else {
                    freeBytes = freeSpace(raf, nextPhysicalOffset);
                }

                if (freeBytes > 0) {
                    pretendToScan.put(section, sectionBuffer);
                }
                continue;
            }

            if (physicalSize - virtualSize >= fileAlignment) {
                log.info("Section " + name + " have overlay");
            }

        }

        log.info("Pretend to scan " + pretendToScan.size());

        for (SectionTable section : pretendToScan.keySet()) {
            String[] sectionFlags = section.getSectionFlags();
            if (!UnsignedTypes.checkCharacteristic(sectionFlags, Constant.IMAGE_SCN_MEM_SHARED) &&
                    !UnsignedTypes.checkCharacteristic(sectionFlags, Constant.IMAGE_SCN_MEM_DISCARDABLE) &&
                    (UnsignedTypes.checkCharacteristic(sectionFlags, Constant.IMAGE_SCN_MEM_READ) || UnsignedTypes.checkCharacteristic(sectionFlags, Constant.IMAGE_SCN_MEM_EXECUTE)) &&
                    (UnsignedTypes.checkCharacteristic(sectionFlags, Constant.IMAGE_SCN_CNT_CODE) || UnsignedTypes.checkCharacteristic(sectionFlags, Constant.IMAGE_SCN_CNT_INITIALIZED_DATA))) {
                sectionToScan.put(section, pretendToScan.get(section));
            }
        }

        log.info("Section to scan " + sectionToScan.size());

        for(SectionTable section : sectionToScan.keySet()){
            return isInfected(sectionToScan.get(section));
        }

        return false;
    }

    private static int freeSpace(@NotNull RandomAccessFile raf, int nextPhysicalOffset) throws IOException {
        int bytesToRead = 512;
        long seekPos = nextPhysicalOffset - bytesToRead;

        byte[] buffer = new byte[bytesToRead];

        raf.seek(seekPos);
        raf.readFully(buffer, 0, bytesToRead);

        return checkBuffer(buffer);
    }

    private static int freeSpace(@NotNull RandomAccessFile raf, int physicalSize, int physicalOffset) throws IOException {
        int bytesToRead = 512;
        int seekPos = physicalOffset + physicalSize - 512;
        byte[] buffer = new byte[bytesToRead];

        if (raf.length() > seekPos) {

            raf.seek(seekPos);
            raf.readFully(buffer, 0, bytesToRead);

            return checkBuffer(buffer);
        }
        return 0;
    }

    private static int checkBuffer(@NotNull byte[] buffer) {
        int freeBytes = 0;
        for (byte b : buffer) {
            if (freeBytes > 256) {
                sectionBuffer = buffer;
                return freeBytes;
            }
            if (b == 0) {
                freeBytes++;
            } else {
                freeBytes = 0;
            }
        }
        return 0;
    }

    private static boolean isInfected(byte[] sectionBuffer) {
        for (Malware malware : malwares) {
            int bytesMatched = 0;
            int l = 0;
            byte[] signature = malware.getByteSignature();
            for (byte b : sectionBuffer) {
                if (signature[l] == b) {
                    l++;
                    bytesMatched++;
                } else {
                    l = 0;
                    bytesMatched = 0;
                }

                if (bytesMatched == signature.length) {
                    log.info("This file infected by " + malware.getMalwareName());
                    return true;
                }
            }
        }

        return false;
    }
}
